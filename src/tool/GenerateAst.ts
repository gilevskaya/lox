// http://craftinginterpreters.com/representing-code.html

import fs from "fs";

const COMMENT = Object.freeze([
  "this file is auto generated by /tools/GenerateAst",
  "http://craftinginterpreters.com/representing-code.html"
]);
const AST_TEMPLATE = Object.freeze({
  Binary: ["left: Expr, operator: lox.TokenType, right: Expr"],
  Group: ["expression: Expr"],
  Literal: ["value: object"],
  Unary: ["operator: lox.TokenType", "right: Expr"]
});

class GenerateAst {
  private static lines: string[] = [];

  public static writeFile() {
    GenerateAst.defineAst();
    const data = GenerateAst.lines.join("\n");

    fs.writeFile("src/lox/Expr.ts", data, err => {
      if (err) throw err;
      console.log("The file has been saved!");
    });
  }

  private static addLine(line: string = "", ind = 0) {
    GenerateAst.lines.push(`${"  ".repeat(ind)}${line}`);
  }

  private static defineAst() {
    COMMENT.forEach(l => GenerateAst.addLine(`// ${l}`));
    GenerateAst.addLine();
    GenerateAst.addLine('import * as lox from "./"');
    GenerateAst.addLine();
    GenerateAst.addLine("export module Expr {");
    GenerateAst.addLine("abstract class Expr {", 1);
    GenerateAst.addLine("// ...", 2);
    GenerateAst.addLine("}", 1);

    Object.entries(AST_TEMPLATE).forEach(([className, fieldList]) =>
      GenerateAst.defineType(className, fieldList, 1)
    );
    GenerateAst.addLine("}");
  }

  private static defineType(
    className: string,
    fieldList: string[],
    baseInd = 0
  ) {
    GenerateAst.addLine();
    GenerateAst.addLine(`export class ${className} extends Expr {`, baseInd);
    GenerateAst.addLine(
      `constructor(${fieldList.map(f => `public ${f}`).join(", ")}) {`,
      baseInd + 1
    );
    GenerateAst.addLine(`super();`, baseInd + 2);
    GenerateAst.addLine(`}`, baseInd + 1);
    GenerateAst.addLine(`}`, baseInd);
  }
}

GenerateAst.writeFile();

// abstract class Expr {
//   abstract accept(visitor: Visitor<R>);
// }

// export class Binary extends Expr {
//   constructor(public left: Expr, public operator: any, public right: Expr) {
//     super();
//   }
//   public accept(visitor: Visitor<R>) {
//     return visitor.visitBinaryExpr(this);
//   }
// }

// export class Grouping extends Expr {
//   constructor(public expression: Expr) {
//     super();
//   }
//   public accept(visitor: Visitor<R>) {
//     return visitor.visitGroupExpr(this);
//   }
// }
